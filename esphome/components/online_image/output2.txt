===== image_decoder.cpp =====
#include "image_decoder.h"
#include "online_image.h"

#include "esphome/core/log.h"

namespace esphome {
namespace online_image {

static const char *const TAG = "online_image.decoder";

void ImageDecoder::set_size(int width, int height) {
  this->image_->resize_(width, height);
  this->x_scale_ = static_cast<double>(this->image_->buffer_width_) / width;
  this->y_scale_ = static_cast<double>(this->image_->buffer_height_) / height;
}

void ImageDecoder::draw(int x, int y, int w, int h, const Color &color) {
  auto width = std::min(this->image_->buffer_width_, static_cast<int>(std::ceil((x + w) * this->x_scale_)));
  auto height = std::min(this->image_->buffer_height_, static_cast<int>(std::ceil((y + h) * this->y_scale_)));
  for (int i = x * this->x_scale_; i < width; i++) {
    for (int j = y * this->y_scale_; j < height; j++) {
      this->image_->draw_pixel_(i, j, color);
    }
  }
}

uint8_t *DownloadBuffer::data(size_t offset) {
  if (offset > this->size_) {
    ESP_LOGE(TAG, "Tried to access beyond download buffer bounds!!!");
    return this->buffer_;
  }
  return this->buffer_ + offset;
}

size_t DownloadBuffer::read(size_t len) {
  this->unread_ -= len;
  if (this->unread_ > 0) {
    memmove(this->data(), this->data(len), this->unread_);
  }
  return this->unread_;
}

}  // namespace online_image
}  // namespace esphome

===== online_image.cpp =====
#include "online_image.h"

#include "esphome/core/log.h"

static const char *const TAG = "online_image";

#include "image_decoder.h"

#ifdef USE_ONLINE_IMAGE_PNG_SUPPORT
#include "png_image.h"
#endif

#ifdef USE_ONLINE_IMAGE_WEBP_SUPPORT
#include "webp_image.h"
#endif

namespace esphome {
namespace online_image {

using image::ImageType;

inline bool is_color_on(const Color &color) {
  // This produces the most accurate monochrome conversion, but is slightly slower.
  //  return (0.2125 * color.r + 0.7154 * color.g + 0.0721 * color.b) > 127;

  // Approximation using fast integer computations; produces acceptable results
  // Equivalent to 0.25 * R + 0.5 * G + 0.25 * B
  return ((color.r >> 2) + (color.g >> 1) + (color.b >> 2)) & 0x80;
}

OnlineImage::OnlineImage(const std::string &url, int width, int height, ImageFormat format, ImageType type,
                         uint32_t download_buffer_size)
    : Image(nullptr, 0, 0, type),
      buffer_(nullptr),
      download_buffer_(download_buffer_size),
      format_(format),
      fixed_width_(width),
      fixed_height_(height) {
  this->set_url(url);
}

void OnlineImage::draw(int x, int y, display::Display *display, Color color_on, Color color_off) {
  if (this->data_start_) {
    Image::draw(x, y, display, color_on, color_off);
  } else if (this->placeholder_) {
    this->placeholder_->draw(x, y, display, color_on, color_off);
  }
}

void OnlineImage::release() {
  if (this->buffer_) {
    ESP_LOGD(TAG, "Deallocating old buffer...");
    this->allocator_.deallocate(this->buffer_, this->get_buffer_size_());
    this->data_start_ = nullptr;
    this->buffer_ = nullptr;
    this->width_ = 0;
    this->height_ = 0;
    this->buffer_width_ = 0;
    this->buffer_height_ = 0;
    this->end_connection_();
  }
}

bool OnlineImage::resize_(int width_in, int height_in) {
  int width = this->fixed_width_;
  int height = this->fixed_height_;
  if (this->auto_resize_()) {
    width = width_in;
    height = height_in;
    if (this->width_ != width && this->height_ != height) {
      this->release();
    }
  }
  if (this->buffer_) {
    return false;
  }
  auto new_size = this->get_buffer_size_(width, height);
  ESP_LOGD(TAG, "Allocating new buffer of %d Bytes...", new_size);
  delay_microseconds_safe(2000);
  this->buffer_ = this->allocator_.allocate(new_size);
  if (this->buffer_) {
    this->buffer_width_ = width;
    this->buffer_height_ = height;
    this->width_ = width;
    ESP_LOGD(TAG, "New size: (%d, %d)", width, height);
  } else {
#if defined(USE_ESP8266)
    // NOLINTNEXTLINE(readability-static-accessed-through-instance)
    int max_block = ESP.getMaxFreeBlockSize();
#elif defined(USE_ESP32)
    int max_block = heap_caps_get_largest_free_block(MALLOC_CAP_INTERNAL);
#else
    int max_block = -1;
#endif
    ESP_LOGE(TAG, "allocation failed. Biggest block in heap: %d Bytes", max_block);
    this->end_connection_();
    return false;
  }
  return true;
}

void OnlineImage::update() {
  if (this->decoder_) {
    ESP_LOGW(TAG, "Image already being updated.");
    return;
  } else {
    ESP_LOGI(TAG, "Updating image");
  }

  this->downloader_ = this->parent_->get(this->url_);

  if (this->downloader_ == nullptr) {
    ESP_LOGE(TAG, "Download failed.");
    this->end_connection_();
    this->download_error_callback_.call();
    return;
  }

  int http_code = this->downloader_->status_code;
  if (http_code == HTTP_CODE_NOT_MODIFIED) {
    // Image hasn't changed on server. Skip download.
    this->end_connection_();
    return;
  }
  if (http_code != HTTP_CODE_OK) {
    ESP_LOGE(TAG, "HTTP result: %d", http_code);
    this->end_connection_();
    this->download_error_callback_.call();
    return;
  }

  ESP_LOGD(TAG, "Starting download");
  size_t total_size = this->downloader_->content_length;

  // Instantiate the appropriate decoder based on the image format
#ifdef USE_ONLINE_IMAGE_PNG_SUPPORT
  if (this->format_ == ImageFormat::PNG) {
    this->decoder_ = esphome::make_unique<PngDecoder>(this);
  }
#endif  // ONLINE_IMAGE_PNG_SUPPORT

#ifdef USE_ONLINE_IMAGE_WEBP_SUPPORT
  if (this->format_ == ImageFormat::WEBP) {
    this->decoder_ = esphome::make_unique<WebPDecoder>(this);
  }
#endif  // ONLINE_IMAGE_WEBP_SUPPORT

  if (!this->decoder_) {
    ESP_LOGE(TAG, "Could not instantiate decoder. Image format unsupported.");
    this->end_connection_();
    this->download_error_callback_.call();
    return;
  }
  this->decoder_->prepare(total_size);
  ESP_LOGI(TAG, "Downloading image");
}

void OnlineImage::loop() {
  if (!this->decoder_) {
    return;
  }
  if (!this->downloader_ || this->decoder_->is_finished()) {
    ESP_LOGD(TAG, "Image fully downloaded");
    this->data_start_ = buffer_;
    this->width_ = buffer_width_;
    this->height_ = buffer_height_;
    this->end_connection_();
    this->download_finished_callback_.call();
    return;
  }
  if (this->downloader_ == nullptr) {
    ESP_LOGE(TAG, "Downloader not instantiated; cannot download");
    return;
  }
  size_t available = this->download_buffer_.free_capacity();
  if (available) {
    auto len = this->downloader_->read(this->download_buffer_.append(), available);
    if (len > 0) {
      this->download_buffer_.write(len);
      auto fed = this->decoder_->decode(this->download_buffer_.data(), this->download_buffer_.unread());
      if (fed < 0) {
        ESP_LOGE(TAG, "Error when decoding image.");
        this->end_connection_();
        this->download_error_callback_.call();
        return;
      }
      this->download_buffer_.read(fed);
    }
  }
}

void OnlineImage::draw_pixel_(int x, int y, Color color) {
  if (!this->buffer_) {
    ESP_LOGE(TAG, "Buffer not allocated!");
    return;
  }
  if (x < 0 || y < 0 || x >= this->buffer_width_ || y >= this->buffer_height_) {
    ESP_LOGE(TAG, "Tried to paint a pixel (%d,%d) outside the image!", x, y);
    return;
  }
  uint32_t pos = this->get_position_(x, y);
  switch (this->type_) {
    case ImageType::IMAGE_TYPE_BINARY: {
      const uint32_t width_8 = ((this->width_ + 7u) / 8u) * 8u;
      const uint32_t pos = x + y * width_8;
      if ((this->has_transparency() && color.w > 127) || is_color_on(color)) {
        this->buffer_[pos / 8u] |= (0x80 >> (pos % 8u));
      } else {
        this->buffer_[pos / 8u] &= ~(0x80 >> (pos % 8u));
      }
      break;
    }
    case ImageType::IMAGE_TYPE_GRAYSCALE: {
      uint8_t gray = static_cast<uint8_t>(0.2125 * color.r + 0.7154 * color.g + 0.0721 * color.b);
      if (this->has_transparency()) {
        if (gray == 1) {
          gray = 0;
        }
        if (color.w < 0x80) {
          gray = 1;
        }
      }
      this->buffer_[pos] = gray;
      break;
    }
    case ImageType::IMAGE_TYPE_RGB565: {
      uint16_t col565 = display::ColorUtil::color_to_565(color);
      if (this->has_transparency()) {
        if (col565 == 0x0020) {
          col565 = 0;
        }
        if (color.w < 0x80) {
          col565 = 0x0020;
        }
      }
      this->buffer_[pos + 0] = static_cast<uint8_t>((col565 >> 8) & 0xFF);
      this->buffer_[pos + 1] = static_cast<uint8_t>(col565 & 0xFF);
      break;
    }
    case ImageType::IMAGE_TYPE_RGBA: {
      this->buffer_[pos + 0] = color.r;
      this->buffer_[pos + 1] = color.g;
      this->buffer_[pos + 2] = color.b;
      this->buffer_[pos + 3] = color.w;
      break;
    }
    case ImageType::IMAGE_TYPE_RGB24:
    default: {
      if (this->has_transparency()) {
        if (color.b == 1 && color.r == 0 && color.g == 0) {
          color.b = 0;
        }
        if (color.w < 0x80) {
          color.r = 0;
          color.g = 0;
          color.b = 1;
        }
      }
      this->buffer_[pos + 0] = color.r;
      this->buffer_[pos + 1] = color.g;
      this->buffer_[pos + 2] = color.b;
      break;
    }
  }
}

void OnlineImage::end_connection_() {
  if (this->downloader_) {
    this->downloader_->end();
    this->downloader_ = nullptr;
  }
  this->decoder_.reset();
  this->download_buffer_.reset();
}

bool OnlineImage::validate_url_(const std::string &url) {
  if ((url.length() < 8) || (url.find("http") != 0) || (url.find("://") == std::string::npos)) {
    ESP_LOGE(TAG, "URL is invalid and/or must be prefixed with 'http://' or 'https://'");
    return false;
  }
  return true;
}

void OnlineImage::add_on_finished_callback(std::function<void()> &&callback) {
  this->download_finished_callback_.add(std::move(callback));
}

void OnlineImage::add_on_error_callback(std::function<void()> &&callback) {
  this->download_error_callback_.add(std::move(callback));
}

}  // namespace online_image
}  // namespace esphome

===== png_image.cpp =====
#include "png_image.h"
#ifdef USE_ONLINE_IMAGE_PNG_SUPPORT

#include "esphome/components/display/display_buffer.h"
#include "esphome/core/application.h"
#include "esphome/core/helpers.h"
#include "esphome/core/log.h"

static const char *const TAG = "online_image.png";

namespace esphome {
namespace online_image {

/**
 * @brief Callback method that will be called by the PNGLE engine when the basic
 * data of the image is received (i.e. width and height);
 *
 * @param pngle The PNGLE object, including the context data.
 * @param w The width of the image.
 * @param h The height of the image.
 */
static void init_callback(pngle_t *pngle, uint32_t w, uint32_t h) {
  PngDecoder *decoder = (PngDecoder *) pngle_get_user_data(pngle);
  decoder->set_size(w, h);
}

/**
 * @brief Callback method that will be called by the PNGLE engine when a chunk
 * of the image is decoded.
 *
 * @param pngle The PNGLE object, including the context data.
 * @param x The X coordinate to draw the rectangle on.
 * @param y The Y coordinate to draw the rectangle on.
 * @param w The width of the rectangle to draw.
 * @param h The height of the rectangle to draw.
 * @param rgba The color to paint the rectangle in.
 */
static void draw_callback(pngle_t *pngle, uint32_t x, uint32_t y, uint32_t w, uint32_t h, uint8_t rgba[4]) {
  PngDecoder *decoder = (PngDecoder *) pngle_get_user_data(pngle);
  Color color(rgba[0], rgba[1], rgba[2], rgba[3]);
  decoder->draw(x, y, w, h, color);
}

void PngDecoder::prepare(uint32_t download_size) {
  ImageDecoder::prepare(download_size);
  pngle_set_user_data(this->pngle_, this);
  pngle_set_init_callback(this->pngle_, init_callback);
  pngle_set_draw_callback(this->pngle_, draw_callback);
}

int HOT PngDecoder::decode(uint8_t *buffer, size_t size) {
  if (size < 256 && size < this->download_size_ - this->decoded_bytes_) {
    ESP_LOGD(TAG, "Waiting for data");
    return 0;
  }
  auto fed = pngle_feed(this->pngle_, buffer, size);
  if (fed < 0) {
    ESP_LOGE(TAG, "Error decoding image: %s", pngle_error(this->pngle_));
  } else {
    this->decoded_bytes_ += fed;
  }
  return fed;
}

}  // namespace online_image
}  // namespace esphome

#endif  // USE_ONLINE_IMAGE_PNG_SUPPORT

===== webp_image.cpp =====
// ===== webp_image.cpp =====
#include "webp_image.h"

namespace esphome {
namespace online_image {

// No additional implementation needed as decoding is handled in webp_image.h

}  // namespace online_image
}  // namespace esphome

===== image_decoder.h =====
#pragma once
#include "esphome/core/defines.h"
#include "esphome/core/color.h"

namespace esphome {
namespace online_image {

class OnlineImage;

/**
 * @brief Class to abstract decoding different image formats.
 */
class ImageDecoder {
 public:
  /**
   * @brief Construct a new Image Decoder object
   *
   * @param image The image to decode the stream into.
   */
  ImageDecoder(OnlineImage *image) : image_(image) {}
  virtual ~ImageDecoder() = default;

  /**
   * @brief Initialize the decoder.
   *
   * @param download_size The total number of bytes that need to be download for the image.
   */
  virtual void prepare(uint32_t download_size) { this->download_size_ = download_size; }

  /**
   * @brief Decode a part of the image. It will try reading from the buffer.
   * There is no guarantee that the whole available buffer will be read/decoded;
   * the method will return the amount of bytes actually decoded, so that the
   * unread content can be moved to the beginning.
   *
   * @param buffer The buffer to read from.
   * @param size   The maximum amount of bytes that can be read from the buffer.
   * @return int   The amount of bytes read. It can be 0 if the buffer does not have enough content to meaningfully
   *               decode anything, or negative in case of a decoding error.
   */
  virtual int decode(uint8_t *buffer, size_t size);

  /**
   * @brief Request the image to be resized once the actual dimensions are known.
   * Called by the callback functions, to be able to access the parent Image class.
   *
   * @param width The image's width.
   * @param height The image's height.
   */
  void set_size(int width, int height);

  /**
   * @brief Draw a rectangle on the display_buffer using the defined color.
   * Will check the given coordinates for out-of-bounds, and clip the rectangle accordingly.
   * In case of binary displays, the color will be converted to binary as well.
   * Called by the callback functions, to be able to access the parent Image class.
   *
   * @param x The left-most coordinate of the rectangle.
   * @param y The top-most coordinate of the rectangle.
   * @param w The width of the rectangle.
   * @param h The height of the rectangle.
   * @param color The color to draw the rectangle with.
   */
  void draw(int x, int y, int w, int h, const Color &color);

  /**
   * @brief Check if the decoding process is finished.
   * The default implementation checks if all the bytes have been decoded.
   *
   * @return true if the image is fully decoded, false otherwise.
   */
  virtual bool is_finished() const { return this->decoded_bytes_ == this->download_size_; }

 protected:
  OnlineImage *image_;
  uint32_t download_size_ = 1;  // Total size of the image in bytes
  uint32_t decoded_bytes_ = 0;  // Number of bytes that have been decoded so far
  double x_scale_ = 1.0;  // Scaling factor for the image's width
  double y_scale_ = 1.0;  // Scaling factor for the image's height
};

class DownloadBuffer {
 public:
  DownloadBuffer(size_t size) : size_(size) {
    this->buffer_ = this->allocator_.allocate(size);
    this->reset();
  }

  virtual ~DownloadBuffer() { this->allocator_.deallocate(this->buffer_, this->size_); }

  uint8_t *data(size_t offset = 0);

  uint8_t *append() { return this->data(this->unread_); }

  size_t unread() const { return this->unread_; }
  size_t size() const { return this->size_; }
  size_t free_capacity() const { return this->size_ - this->unread_; }

  size_t read(size_t len);
  size_t write(size_t len) {
    this->unread_ += len;
    return this->unread_;
  }

  void reset() { this->unread_ = 0; }

 protected:
  ExternalRAMAllocator<uint8_t> allocator_;
  uint8_t *buffer_;
  size_t size_;
  size_t unread_;  // Total number of downloaded bytes not yet read
};

}  // namespace online_image
}  // namespace esphome

===== online_image.h =====
#pragma once

#include "esphome/core/component.h"
#include "esphome/core/defines.h"
#include "esphome/core/helpers.h"
#include "esphome/components/http_request/http_request.h"
#include "esphome/components/image/image.h"

#include "image_decoder.h"

namespace esphome {
namespace online_image {

using t_http_codes = enum {
  HTTP_CODE_OK = 200,
  HTTP_CODE_NOT_MODIFIED = 304,
  HTTP_CODE_NOT_FOUND = 404,
};

/**
 * @brief Format that the image is encoded with.
 */
enum ImageFormat {
  /** Automatically detect from MIME type. Not supported yet. */
  AUTO,
  /** JPEG format. Not supported yet. */
  JPEG,
  /** PNG format. */
  PNG,
  /** WEBP format */
  WEBP,
};

/**
 * @brief Download an image from a given URL, and decode it using the specified decoder.
 * The image will then be stored in a buffer, so that it can be re-displayed without the
 * need to re-download or re-decode.
 */
class OnlineImage : public PollingComponent,
                    public image::Image,
                    public Parented<esphome::http_request::HttpRequestComponent> {
 public:
  /**
   * @brief Construct a new OnlineImage object.
   *
   * @param url URL to download the image from.
   * @param width Desired width of the target image area.
   * @param height Desired height of the target image area.
   * @param format Format that the image is encoded in (@see ImageFormat).
   * @param buffer_size Size of the buffer used to download the image.
   */
  OnlineImage(const std::string &url, int width, int height, ImageFormat format, image::ImageType type,
              uint32_t buffer_size);

  void draw(int x, int y, display::Display *display, Color color_on, Color color_off) override;

  void update() override;
  void loop() override;

  /** Set the URL to download the image from. */
  void set_url(const std::string &url) {
    if (this->validate_url_(url)) {
      this->url_ = url;
    }
  }

  /**
   * @brief Set the image that needs to be shown as long as the downloaded image
   *  is not available.
   *
   * @param placeholder Pointer to the (@link Image) to show as placeholder.
   */
  void set_placeholder(image::Image *placeholder) { this->placeholder_ = placeholder; }

  /**
   * Release the buffer storing the image. The image will need to be downloaded again
   * to be able to be displayed.
   */
  void release();

  void add_on_finished_callback(std::function<void()> &&callback);
  void add_on_error_callback(std::function<void()> &&callback);

 protected:
  bool validate_url_(const std::string &url);

  using Allocator = ExternalRAMAllocator<uint8_t>;
  Allocator allocator_{Allocator::Flags::ALLOW_FAILURE};

  uint32_t get_buffer_size_() const { return get_buffer_size_(this->buffer_width_, this->buffer_height_); }
  int get_buffer_size_(int width, int height) const {
    return std::ceil(image::image_type_to_bpp(this->type_) * width * height / 8.0);
  }

  int get_position_(int x, int y) const {
    return ((x + y * this->buffer_width_) * image::image_type_to_bpp(this->type_)) / 8;
  }

  ESPHOME_ALWAYS_INLINE bool auto_resize_() const { return this->fixed_width_ == 0 || this->fixed_height_ == 0; }

  bool resize_(int width, int height);

  /**
   * @brief Draw a pixel into the buffer.
   *
   * This is used by the decoder to fill the buffer that will later be displayed
   * by the `draw` method. This will internally convert the supplied 32 bit RGBA
   * color into the requested image storage format.
   *
   * @param x Horizontal pixel position.
   * @param y Vertical pixel position.
   * @param color 32 bit color to put into the pixel.
   */
  void draw_pixel_(int x, int y, Color color);

  void end_connection_();

  CallbackManager<void()> download_finished_callback_{};
  CallbackManager<void()> download_error_callback_{};

  std::shared_ptr<http_request::HttpContainer> downloader_{nullptr};
  std::unique_ptr<ImageDecoder> decoder_{nullptr};

  uint8_t *buffer_;
  DownloadBuffer download_buffer_;

  const ImageFormat format_;
  image::Image *placeholder_{nullptr};

  std::string url_{""};

  /** width requested on configuration, or 0 if non specified. */
  const int fixed_width_;
  /** height requested on configuration, or 0 if non specified. */
  const int fixed_height_;
  /**
   * Actual width of the current image. If fixed_width_ is specified,
   * this will be equal to it; otherwise it will be set once the decoding
   * starts and the original size is known.
   * This needs to be separate from "BaseImage::get_width()" because the latter
   * must return 0 until the image has been decoded (to avoid showing partially
   * decoded images).
   */
  int buffer_width_;
  /**
   * Actual height of the current image. If fixed_height_ is specified,
   * this will be equal to it; otherwise it will be set once the decoding
   * starts and the original size is known.
   * This needs to be separate from "BaseImage::get_height()" because the latter
   * must return 0 until the image has been decoded (to avoid showing partially
   * decoded images).
   */
  int buffer_height_;

  friend void ImageDecoder::set_size(int width, int height);
  friend void ImageDecoder::draw(int x, int y, int w, int h, const Color &color);
  friend class WebPDecoder;
};

template<typename... Ts> class OnlineImageSetUrlAction : public Action<Ts...> {
 public:
  OnlineImageSetUrlAction(OnlineImage *parent) : parent_(parent) {}
  TEMPLATABLE_VALUE(std::string, url)
  void play(Ts... x) override {
    this->parent_->set_url(this->url_.value(x...));
    this->parent_->update();
  }

 protected:
  OnlineImage *parent_;
};

template<typename... Ts> class OnlineImageReleaseAction : public Action<Ts...> {
 public:
  OnlineImageReleaseAction(OnlineImage *parent) : parent_(parent) {}
  void play(Ts... x) override { this->parent_->release(); }

 protected:
  OnlineImage *parent_;
};

class DownloadFinishedTrigger : public Trigger<> {
 public:
  explicit DownloadFinishedTrigger(OnlineImage *parent) {
    parent->add_on_finished_callback([this]() { this->trigger(); });
  }
};

class DownloadErrorTrigger : public Trigger<> {
 public:
  explicit DownloadErrorTrigger(OnlineImage *parent) {
    parent->add_on_error_callback([this]() { this->trigger(); });
  }
};

}  // namespace online_image
}  // namespace esphome

===== png_image.h =====
#pragma once

#include "image_decoder.h"
#ifdef USE_ONLINE_IMAGE_PNG_SUPPORT
#include <pngle.h>

namespace esphome {
namespace online_image {

/**
 * @brief Image decoder specialization for PNG images.
 */
class PngDecoder : public ImageDecoder {
 public:
  /**
   * @brief Construct a new PNG Decoder object.
   *
   * @param display The image to decode the stream into.
   */
  PngDecoder(OnlineImage *image) : ImageDecoder(image), pngle_(pngle_new()) {}
  ~PngDecoder() override { pngle_destroy(this->pngle_); }

  void prepare(uint32_t download_size) override;
  int HOT decode(uint8_t *buffer, size_t size) override;

 protected:
  pngle_t *pngle_;
};

}  // namespace online_image
}  // namespace esphome

#endif  // USE_ONLINE_IMAGE_PNG_SUPPORT

===== webp_image.h =====
#pragma once

#include "image_decoder.h"
#include "esphome/core/log.h"
#include "webp/decode.h"  // Include libwebp's decode header
#include "online_image.h"  // Include the full definition of OnlineImage

namespace esphome {
namespace online_image {

static const char *const TAG = "online_image.webp";

/**
 * @brief Image decoder specialization for WebP images using libwebp and incremental decoding.
 */
class WebPDecoder : public ImageDecoder {
 public:
  WebPDecoder(OnlineImage *parent) 
      : ImageDecoder(parent), 
        parent_(parent), 
        decoder_ready_(false), 
        webp_decoder_(nullptr),
        size_set_(false) {}

  ~WebPDecoder() override {
    if (webp_decoder_ != nullptr) {
      WebPIDelete(webp_decoder_);
    }
  }

  /**
   * @brief Initialize the decoder.
   *
   * @param download_size The total number of bytes to download for the image.
   */
  virtual void prepare(uint32_t download_size) override {
    ESP_LOGD(TAG, "WebPDecoder::prepare called with total_size: %u", download_size);
    this->download_size_ = download_size;
    this->decoded_bytes_ = 0;
    this->size_set_ = false;
    this->decoder_ready_ = false;
    parent_->buffer_ = nullptr;  // Access the buffer from OnlineImage
    this->temp_buffer_.clear();
  }

  /**
   * @brief Decode a chunk of the image.
   *
   * @param data Pointer to the data buffer.
   * @param length Number of bytes to decode.
   * @return int Number of bytes processed, or -1 on error.
   */
  int decode(unsigned char* data, unsigned int length) override {
    ESP_LOGD(TAG, "WebPDecoder::decode called with %u bytes", length);

    if (!this->size_set_) {
      // Accumulate data until we can determine image dimensions
      temp_buffer_.insert(temp_buffer_.end(), data, data + length);
      ESP_LOGD(TAG, "WebPDecoder::decode: Accumulated %zu bytes for WebP info.", temp_buffer_.size());

      int width = 0, height = 0;  // Match the types expected by WebPGetInfo
      if (WebPGetInfo(temp_buffer_.data(), temp_buffer_.size(), &width, &height)) {
        ESP_LOGI(TAG, "WebPDecoder::decode: Image dimensions obtained: %u x %u", width, height);
        this->set_size(width, height);  // Allocates the buffer via OnlineImage

        if (parent_->buffer_ == nullptr) {
          ESP_LOGE(TAG, "WebPDecoder::decode: Image buffer not allocated in OnlineImage. Cannot proceed with decoding.");
          return -1;
        }

        // Initialize WebPDecoderConfig
        if (!WebPInitDecoderConfig(&config_)) {
          ESP_LOGE(TAG, "WebPDecoder::decode: Failed to initialize WebP decoder configuration.");
          return -1;
        }

        // Configure the output buffer
        config_.output.colorspace = MODE_RGBA;
        config_.output.u.RGBA.rgba = parent_->buffer_;
        config_.output.u.RGBA.stride = parent_->fixed_width_ * 4;  // 4 bytes per pixel (RGBA)
        config_.output.u.RGBA.size = parent_->fixed_width_ * parent_->fixed_height_ * 4;

        // Initialize the incremental decoder
        webp_decoder_ = WebPINewDecoder(&config_.output);
        if (webp_decoder_ == nullptr) {
          ESP_LOGE(TAG, "WebPDecoder::decode: Failed to initialize WebP incremental decoder.");
          return -1;
        }

        this->decoder_ready_ = true;
        this->size_set_ = true;
        ESP_LOGI(TAG, "WebPDecoder::decode: Decoder initialized and ready.");

        // Feed the accumulated data to the decoder
        VP8StatusCode status = WebPIAppend(webp_decoder_, temp_buffer_.data(), temp_buffer_.size());
        if (status != VP8_STATUS_OK && status != VP8_STATUS_SUSPENDED) {
          ESP_LOGE(TAG, "WebPDecoder::decode: Error decoding WebP image during initial append, status code: %d", status);
          WebPIDelete(webp_decoder_);
          webp_decoder_ = nullptr;
          return -1;
        }

        ESP_LOGD(TAG, "WebPDecoder::decode: Decoded initial %zu bytes.", temp_buffer_.size());
        decoded_bytes_ += temp_buffer_.size();
        temp_buffer_.clear();

        return length;  // All bytes have been processed
      }

      // Not enough data to get info yet
      ESP_LOGD(TAG, "WebPDecoder::decode: Insufficient data to determine image dimensions.");
      return 0;
    }

    if (!this->decoder_ready_) {
      ESP_LOGE(TAG, "WebPDecoder::decode: Decoder not ready. Ensure that prepare() was called and succeeded.");
      return -1;
    }

    // Feed data to the incremental decoder
    VP8StatusCode status = WebPIAppend(webp_decoder_, data, length);
    if (status == VP8_STATUS_OK || status == VP8_STATUS_SUSPENDED) {
      ESP_LOGD(TAG, "WebPDecoder::decode: Successfully decoded %u bytes.", length);
      decoded_bytes_ += length;
      return length;  // All bytes have been processed
    } else {
      ESP_LOGE(TAG, "WebPDecoder::decode: Error decoding WebP image, status code: %d", status);
      WebPIDelete(webp_decoder_);
      webp_decoder_ = nullptr;
      return -1;
    }
  }

  /**
   * @brief Check if the decoding process is finished.
   *
   * @return true If decoding is complete.
   * @return false Otherwise.
   */
  bool is_finished()  {
    ESP_LOGD(TAG, "WebPDecoder::is_finished called.");

    if (webp_decoder_ == nullptr) {
      ESP_LOGD(TAG, "WebPDecoder::is_finished: WebP decoder is null, decoding considered finished.");
      return true;
    }

    // Retrieve decoded area
    int left, top, width, height;
    if (WebPIDecodedArea(webp_decoder_, &left, &top, &width, &height)) {
      ESP_LOGD(TAG, "WebPDecoder::is_finished: Decoded area (%d, %d) - Width: %d, Height: %d", left, top, width, height);
      if (width == parent_->fixed_width_ && height == parent_->fixed_height_) {
        ESP_LOGI(TAG, "WebPDecoder::is_finished: WebP image decoding complete.");
        WebPIDelete(webp_decoder_);
        webp_decoder_ = nullptr;
        return true;
      }
    }

    ESP_LOGD(TAG, "WebPDecoder::is_finished: Decoding not yet complete.");
    return false;
  }

 private:
  OnlineImage *parent_;
  bool decoder_ready_;
  bool size_set_;
  WebPIDecoder *webp_decoder_;
  WebPDecoderConfig config_;
  std::vector<uint8_t> temp_buffer_;
};

}  // namespace online_image
}  // namespace esphome

